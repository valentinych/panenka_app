{% extends "base.html" %}
{% block masthead %}{% endblock %}
{% block title %}–ò–≥—Ä–∞ ¬´10¬ª ¬∑ Panenka Live{% endblock %}
{% block layout_modifier %} layout--full layout--game-ten{% endblock %}
{% block content %}
<div class="game-ten" data-active-url="{{ game_ten_active_url }}" data-run-url="{{ game_ten_run_url }}">
  <p class="game-ten__error" data-role="error" hidden></p>

  <section class="card game-ten__hud">
    <div class="game-ten__brand">
      <h1 class="brand brand--hud">
        <a class="brand-link" href="{{ url_for('main.dashboard') }}" data-role="home-link">
          <span aria-hidden="true" class="brand-logo">
            <span class="brand-logo__inner">10</span>
          </span>
          <span class="brand-name">–î–ï–°–Ø–¢–¨</span>
        </a>
      </h1>
    </div>
    <div class="game-ten__hud-meta">
      <div class="game-ten__question-header">
        <div class="game-ten__question-badge">
          <span class="game-ten__question-number" data-role="question-number">‚Äì</span>
          <div class="game-ten__question-meta">
            <div class="game-ten__theme" data-role="theme">–¢–µ–º–∞ –≤–æ–ø—Ä–æ—Å–∞</div>
            <div class="game-ten__subtitle" data-role="subtitle" hidden>–¢–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞ –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω</div>
          </div>
        </div>
        <div class="game-ten__active-player">
          <label class="game-ten__active-label" for="game-ten-active-player">–ò–≥—Ä–æ–∫ –Ω–∞ –≤–æ–ø—Ä–æ—Å–µ</label>
          <div class="game-ten__active-select-wrapper">
            <select id="game-ten-active-player" class="game-ten__active-select" data-role="active-player"></select>
          </div>
        </div>
      </div>
    </div>
    <div class="game-ten__hud-teams">
      {% for idx in range(2) %}
      <article class="game-ten__team-card" data-team-slot="{{ idx }}">
        <header class="game-ten__team-header">
          <div class="game-ten__team-title">
            <div class="game-ten__team-name" data-role="team-name">–ö–æ–º–∞–Ω–¥–∞ {{ idx + 1 }}</div>
            <div class="game-ten__hints" data-role="hints"></div>
          </div>
          <div class="game-ten__timer-bar">
            <div class="game-ten__timer-display" data-role="timer-display">20:00</div>
            <div class="game-ten__timer-controls">
              <button
                type="button"
                class="game-ten__timer-btn game-ten__timer-btn--icon"
                data-action="toggle"
                aria-label="–ó–∞–ø—É—Å—Ç–∏—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–∞–π–º–µ—Ä"
              >
                <span class="game-ten__timer-icon" aria-hidden="true">‚ñ∂</span>
                <span class="sr-only">–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç–∞–π–º–µ—Ä</span>
              </button>
              <button type="button" class="game-ten__timer-btn" data-action="plus">+10</button>
              <button type="button" class="game-ten__timer-btn" data-action="minus">-10</button>
            </div>
          </div>
          <button type="button" class="game-ten__team-life" data-role="team-life" aria-pressed="true">
            <span class="sr-only">–ö–æ–º–∞–Ω–¥–Ω–∞—è –∂–∏–∑–Ω—å</span>
          </button>
        </header>
        <div class="game-ten__players" data-role="players"></div>
      </article>
      {% endfor %}
    </div>
  </section>

  <section class="card game-ten__board">
    <div class="game-ten__selection" data-role="question-selection">
      <h2 class="game-ten__selection-title">–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É –≤–æ–ø—Ä–æ—Å–∞</h2>
      <div class="game-ten__selection-grid" data-role="question-grid"></div>
    </div>
    <div class="game-ten__question-view" data-role="question-view" hidden>
      <div class="game-ten__prompt">
        <div class="game-ten__prompt-text" data-role="prompt-text">–¢–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ game_active.json</div>
      </div>
      <div class="game-ten__grid" data-role="answer-grid">
        {% for idx in range(10) %}
        <article class="game-ten__tile" data-index="{{ idx }}" tabindex="0">
          <div class="game-ten__tile-image is-empty" data-role="tile-image">
            <span class="game-ten__tile-placeholder">–ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</span>
            <img data-role="tile-img" alt="" loading="lazy" hidden>
          </div>
          <div class="game-ten__tile-caption" data-role="tile-caption">–û—Ç–≤–µ—Ç {{ idx + 1 }}</div>
        </article>
        {% endfor %}
      </div>
    </div>
  </section>

  <section class="card game-ten__reveal">
    <div class="game-ten__reveal-body" data-role="reveal-body" hidden></div>
  </section>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const gameRoot = document.querySelector('.game-ten');
    if (!gameRoot) {
      return;
    }

    function resolveAssetUrl(rawValue, fallback = '') {
      const value = (rawValue || fallback || '').trim();
      if (!value) {
        return '';
      }
      try {
        return new URL(value, window.location.origin).toString();
      } catch (error) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞—Ç—å URL —Ä–µ—Å—É—Ä—Å–∞, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∏—Å—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.', value, error);
        return value;
      }
    }

    const activeUrl = resolveAssetUrl(gameRoot.dataset.activeUrl, 'game_active.json');
    const runUrl = resolveAssetUrl(gameRoot.dataset.runUrl, 'game_run.json');
    const errorNode = gameRoot.querySelector('[data-role="error"]');

    const MAX_PLAYER_LIVES = 3;
    const DEFAULT_TIMER_SECONDS = 20 * 60;
    const HINT_ICONS = {
      pass: '‚è≠',
      switch: 'üîÑ',
      opponent: 'üéØ',
    };

    const timerControllers = new Map();
    let saveTimerId = null;

    function showError(message) {
      if (!errorNode) {
        return;
      }
      errorNode.textContent = message;
      errorNode.hidden = false;
    }

    function hideError() {
      if (!errorNode) {
        return;
      }
      errorNode.hidden = true;
      errorNode.textContent = '';
    }

    async function loadJson(url, options = {}) {
      if (!url) {
        throw new Error('URL –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–µ –∑–∞–¥–∞–Ω.');
      }
      const { allowNotFound = false } = options || {};
      const response = await fetch(url, { cache: 'no-store' });
      if (!response.ok) {
        if (allowNotFound && response.status === 404) {
          return null;
        }
        const error = new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ (${response.status}).`);
        error.status = response.status;
        throw error;
      }
      return response.json();
    }

    let tileSizingFrame = null;

    function updateGridSizing() {
      const grid = gameRoot.querySelector('[data-role="answer-grid"]');
      const questionView = gameRoot.querySelector('[data-role="question-view"]');
      if (!grid) {
        return;
      }
      if (!questionView || questionView.hidden) {
        grid.style.gridAutoRows = '';
        return;
      }

      const computed = window.getComputedStyle(grid);
      const templateColumns = computed.gridTemplateColumns || '';
      const columnCount = templateColumns
        .split(' ')
        .map((value) => value.trim())
        .filter(Boolean)
        .length || 1;

      const tiles = Array.from(grid.querySelectorAll('.game-ten__tile')).filter(
        (tile) => !tile.classList.contains('is-hidden'),
      );
      const totalTiles = tiles.length || 10;
      const rows = Math.max(1, Math.ceil(totalTiles / columnCount));

      const columnGap = Number.parseFloat(computed.columnGap || computed.gap || '0') || 0;
      const rowGap = Number.parseFloat(computed.rowGap || computed.gap || '0') || 0;
      const gridWidth = grid.clientWidth;
      const tilesWidth = gridWidth - Math.max(0, columnCount - 1) * columnGap;
      const maxTileWidth = columnCount > 0 ? tilesWidth / columnCount : gridWidth;

      const layout = gameRoot.closest('.layout');
      const layoutStyle = layout ? window.getComputedStyle(layout) : null;
      const layoutPaddingBottom = layoutStyle ? Number.parseFloat(layoutStyle.paddingBottom || '0') || 0 : 0;
      const rootGap = Number.parseFloat(window.getComputedStyle(gameRoot).gap || '0') || 0;

      const reveal = gameRoot.querySelector('.game-ten__reveal');
      const revealRect = reveal && !reveal.hidden ? reveal.getBoundingClientRect() : null;

      const gridRect = grid.getBoundingClientRect();
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
      let availableHeight = viewportHeight - gridRect.top - layoutPaddingBottom;

      if (revealRect) {
        availableHeight = Math.min(availableHeight, revealRect.top - gridRect.top - rootGap);
      }

      const rowsHeight = availableHeight - Math.max(0, rows - 1) * rowGap;
      const maxTileHeight = rowsHeight > 0 ? rowsHeight / rows : maxTileWidth;

      const tileSize = Math.max(96, Math.min(maxTileWidth, maxTileHeight));

      if (Number.isFinite(tileSize)) {
        grid.style.gridAutoRows = `${tileSize}px`;
      } else {
        grid.style.gridAutoRows = '';
      }
    }

    function scheduleGridSizing() {
      if (tileSizingFrame !== null) {
        return;
      }
      tileSizingFrame = window.requestAnimationFrame(() => {
        tileSizingFrame = null;
        updateGridSizing();
      });
    }

    window.addEventListener('resize', scheduleGridSizing);
    window.addEventListener('orientationchange', scheduleGridSizing);

    function autosizeSelect(select) {
      if (!select || !document.body) {
        return;
      }
      const computed = window.getComputedStyle(select);
      const measure = document.createElement('span');
      measure.style.visibility = 'hidden';
      measure.style.position = 'absolute';
      measure.style.whiteSpace = 'pre';
      measure.style.font = computed.font || `${computed.fontWeight} ${computed.fontSize} ${computed.fontFamily}`;
      measure.style.letterSpacing = computed.letterSpacing;
      measure.style.padding = '0';
      measure.style.border = '0';
      document.body.appendChild(measure);
      let maxWidth = 0;
      Array.from(select.options).forEach((option) => {
        measure.textContent = option.textContent || option.label || '';
        const width = measure.getBoundingClientRect().width;
        if (width > maxWidth) {
          maxWidth = width;
        }
      });
      measure.remove();
      if (!(maxWidth > 0)) {
        select.style.width = '';
        return;
      }
      const paddingLeft = Number.parseFloat(computed.paddingLeft) || 0;
      const paddingRight = Number.parseFloat(computed.paddingRight) || 0;
      const borderLeft = Number.parseFloat(computed.borderLeftWidth) || 0;
      const borderRight = Number.parseFloat(computed.borderRightWidth) || 0;
      const extra = 28; // —à–∏—Ä–∏–Ω–∞ —Å—Ç—Ä–µ–ª–∫–∏ –∏ –∑–∞–ø–∞—Å –Ω–∞ –ø—Ä–æ–∫—Ä—É—Ç–∫—É
      const finalWidth = Math.ceil(maxWidth + paddingLeft + paddingRight + borderLeft + borderRight + extra);
      select.style.width = `${finalWidth}px`;
    }

    function formatTime(totalSeconds) {
      const safeSeconds = Math.max(0, Math.round(totalSeconds));
      const minutes = Math.floor(safeSeconds / 60);
      const seconds = safeSeconds % 60;
      return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function normalizeQuestions(activeData) {
      const questions = Array.isArray(activeData?.questions) ? activeData.questions : [];
      return questions.map((question, index) => {
        const normalizedId = typeof question?.id === 'string' && question.id.trim()
          ? question.id.trim()
          : `question-${index + 1}`;
        const answers = Array.isArray(question?.answers) ? question.answers : [];
        const numberValue = Number.isFinite(question?.number) ? Number(question.number) : index + 1;
        return {
          id: normalizedId,
          index,
          number: numberValue,
          theme: typeof question?.theme === 'string' ? question.theme.trim() : '',
          title: typeof question?.title === 'string' ? question.title.trim() : '',
          subtitle: typeof question?.subtitle === 'string' ? question.subtitle.trim() : '',
          prompt: typeof question?.prompt === 'string' ? question.prompt.trim() : '',
          answers,
        };
      });
    }

    function createDefaultState(activeData, questions) {
      const timerSeconds = Number(activeData?.timer_seconds);
      const initialTimer = Number.isFinite(timerSeconds) && timerSeconds > 0 ? timerSeconds : DEFAULT_TIMER_SECONDS;

      const teams = Array.isArray(activeData?.teams) ? activeData.teams : [];

      const state = {
        version: 2,
        updatedAt: new Date().toISOString(),
        activePlayerId: typeof activeData?.active_player_id === 'string' ? activeData.active_player_id : null,
        selectedQuestionId: null,
        questionStates: {},
        timers: {},
        players: {},
        teamLives: {},
        hints: {},
        initialTimers: {},
      };

      teams.forEach((team, index) => {
        const teamId = typeof team?.id === 'string' && team.id.trim() ? team.id.trim() : `team-${index + 1}`;
        state.timers[teamId] = {
          remaining: initialTimer,
          running: false,
          lastStartedAt: null,
        };
        state.initialTimers[teamId] = initialTimer;
        state.teamLives[teamId] = true;
        state.players[teamId] = {};
        const players = Array.isArray(team?.players) ? team.players : [];
        players.forEach((player, playerIndex) => {
          const playerId = typeof player?.id === 'string' && player.id.trim()
            ? player.id.trim()
            : `${teamId}-player-${playerIndex + 1}`;
          state.players[teamId][playerId] = { lives: MAX_PLAYER_LIVES };
        });
      });

      const hints = Array.isArray(activeData?.hints) ? activeData.hints : [];
      Object.keys(state.players).forEach((teamId) => {
        state.hints[teamId] = {};
        hints.forEach((hint, hintIndex) => {
          const hintId = typeof hint?.id === 'string' && hint.id.trim()
            ? hint.id.trim()
            : `hint-${hintIndex + 1}`;
          state.hints[teamId][hintId] = true;
        });
      });

      questions.forEach((question) => {
        state.questionStates[question.id] = {
          answers: question.answers.map(() => ({ status: 'neutral', revealed: false })),
          selectedAnswer: null,
          used: false,
        };
      });

      return state;
    }

    function mergeState(defaultState, savedState, activeData, questions) {
      if (!savedState || typeof savedState !== 'object') {
        return defaultState;
      }

      const merged = JSON.parse(JSON.stringify(defaultState));

      if (typeof savedState.activePlayerId === 'string') {
        merged.activePlayerId = savedState.activePlayerId;
      }

      if (typeof savedState.selectedQuestionId === 'string') {
        merged.selectedQuestionId = savedState.selectedQuestionId;
      } else if (savedState.selectedQuestionId === null) {
        merged.selectedQuestionId = null;
      }

      if (savedState.questionStates && typeof savedState.questionStates === 'object') {
        questions.forEach((question) => {
          const questionId = question.id;
          const defaultQuestionState = merged.questionStates[questionId] || {
            answers: question.answers.map(() => ({ status: 'neutral', revealed: false })),
            selectedAnswer: null,
            used: false,
          };
          merged.questionStates[questionId] = defaultQuestionState;

          const savedQuestionState = savedState.questionStates[questionId];
          if (!savedQuestionState || typeof savedQuestionState !== 'object') {
            return;
          }

          if (Array.isArray(savedQuestionState.answers)) {
            defaultQuestionState.answers = defaultQuestionState.answers.map((entry, index) => {
              const savedEntry = savedQuestionState.answers[index];
              if (!savedEntry || typeof savedEntry !== 'object') {
                return entry;
              }
              const allowedStatuses = ['neutral', 'correct', 'incorrect'];
              const status = allowedStatuses.includes(savedEntry.status) ? savedEntry.status : entry.status;
              const revealed = Boolean(savedEntry.revealed);
              return { status, revealed };
            });
          }

          if (Number.isInteger(savedQuestionState.selectedAnswer)) {
            if (defaultQuestionState.answers.length > 0) {
              defaultQuestionState.selectedAnswer = Math.min(
                Math.max(savedQuestionState.selectedAnswer, 0),
                defaultQuestionState.answers.length - 1,
              );
            } else {
              defaultQuestionState.selectedAnswer = null;
            }
          } else if (savedQuestionState.selectedAnswer === null) {
            defaultQuestionState.selectedAnswer = null;
          }

          if (typeof savedQuestionState.used === 'boolean') {
            defaultQuestionState.used = savedQuestionState.used;
          }
        });
      }

      Object.entries(merged.timers).forEach(([teamId, timerState]) => {
        const savedTimer = savedState.timers && savedState.timers[teamId];
        if (!savedTimer) {
          return;
        }
        if (Number.isFinite(savedTimer.remaining)) {
          timerState.remaining = Math.max(0, Number(savedTimer.remaining));
        }
        timerState.running = Boolean(savedTimer.running);
        timerState.lastStartedAt = typeof savedTimer.lastStartedAt === 'string' && savedTimer.lastStartedAt
          ? savedTimer.lastStartedAt
          : null;
      });

      Object.entries(merged.players).forEach(([teamId, players]) => {
        const savedPlayers = savedState.players && savedState.players[teamId];
        if (!savedPlayers) {
          return;
        }
        Object.entries(players).forEach(([playerId, playerState]) => {
          const savedPlayer = savedPlayers[playerId];
          if (!savedPlayer) {
            return;
          }
          if (Number.isFinite(savedPlayer.lives)) {
            playerState.lives = Math.min(Math.max(Math.round(savedPlayer.lives), 0), MAX_PLAYER_LIVES);
          }
        });
      });

      Object.entries(merged.teamLives).forEach(([teamId]) => {
        if (typeof savedState.teamLives?.[teamId] === 'boolean') {
          merged.teamLives[teamId] = savedState.teamLives[teamId];
        }
      });

      Object.entries(merged.hints).forEach(([teamId, hintMap]) => {
        const savedHints = savedState.hints && savedState.hints[teamId];
        if (!savedHints) {
          return;
        }
        Object.keys(hintMap).forEach((hintId) => {
          if (typeof savedHints[hintId] === 'boolean') {
            hintMap[hintId] = savedHints[hintId];
          }
        });
      });

      merged.initialTimers = merged.initialTimers || {};
      if (savedState.initialTimers && typeof savedState.initialTimers === 'object') {
        Object.entries(savedState.initialTimers).forEach(([teamId, value]) => {
          if (Number.isFinite(value)) {
            merged.initialTimers[teamId] = Math.max(0, Number(value));
          }
        });
      }

      if (typeof savedState.updatedAt === 'string') {
        merged.updatedAt = savedState.updatedAt;
      }

      return merged;
    }

    function scheduleSave(state) {
      if (!runUrl) {
        return;
      }
      if (saveTimerId !== null) {
        window.clearTimeout(saveTimerId);
      }
      saveTimerId = window.setTimeout(async () => {
        saveTimerId = null;
        const payload = {
          ...state,
          updatedAt: new Date().toISOString(),
        };
        try {
          const response = await fetch(runUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ (${response.status}).`);
          }
          hideError();
        } catch (error) {
          console.error(error);
          showError('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ AWS.');
        }
      }, 400);
    }

    function setupTimers(state, teams) {
      timerControllers.forEach((controller) => {
        window.clearInterval(controller.intervalId);
      });
      timerControllers.clear();

      teams.forEach((teamCard) => {
        const teamId = teamCard.dataset.teamId;
        const timerDisplay = teamCard.querySelector('[data-role="timer-display"]');
        const toggleBtn = teamCard.querySelector('[data-action="toggle"]');
        const plusBtn = teamCard.querySelector('[data-action="plus"]');
        const minusBtn = teamCard.querySelector('[data-action="minus"]');
        const toggleIcon = toggleBtn?.querySelector('.game-ten__timer-icon');
        const timerState = state.timers[teamId];
        if (!timerDisplay || !timerState) {
          return;
        }

        const controller = {
          intervalId: null,
          lastTick: null,
        };

        function updateDisplay() {
          timerDisplay.textContent = formatTime(timerState.remaining);
          if (toggleBtn) {
            toggleBtn.setAttribute('aria-pressed', timerState.running ? 'true' : 'false');
            const toggleLabel = timerState.running ? '–ü–∞—É–∑–∞ —Ç–∞–π–º–µ—Ä–∞' : '–ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç–∞–π–º–µ—Ä';
            toggleBtn.title = toggleLabel;
            toggleBtn.setAttribute('aria-label', toggleLabel);
            if (toggleIcon) {
              toggleIcon.textContent = timerState.running ? '‚è∏' : '‚ñ∂';
            }
          }
        }

        function syncTimer() {
          if (!timerState.running) {
            controller.lastTick = Date.now();
            return;
          }
          const now = Date.now();
          if (controller.lastTick !== null) {
            const elapsed = (now - controller.lastTick) / 1000;
            if (Number.isFinite(elapsed) && elapsed > 0) {
              timerState.remaining = Math.max(0, timerState.remaining - elapsed);
            }
          }
          controller.lastTick = now;
        }

        function stopTimer({ silent } = { silent: false }) {
          if (!timerState.running) {
            return;
          }
          syncTimer();
          timerState.running = false;
          timerState.lastStartedAt = null;
          if (controller.intervalId !== null) {
            window.clearInterval(controller.intervalId);
            controller.intervalId = null;
          }
          updateDisplay();
          if (!silent) {
            scheduleSave(state);
          }
        }

        function startInterval() {
          if (controller.intervalId !== null) {
            window.clearInterval(controller.intervalId);
          }
          controller.lastTick = Date.now();
          controller.intervalId = window.setInterval(() => {
            syncTimer();
            updateDisplay();
            if (timerState.remaining <= 0) {
              stopTimer({ silent: false });
            }
          }, 250);
        }

        function startTimer() {
          if (timerState.running) {
            return;
          }
          syncTimer();
          timerState.running = true;
          timerState.lastStartedAt = new Date().toISOString();
          startInterval();
          updateDisplay();
          scheduleSave(state);
        }

        function adjust(secondsDelta) {
          if (timerState.running) {
            syncTimer();
            timerState.lastStartedAt = new Date().toISOString();
          }
          timerState.remaining = Math.max(0, timerState.remaining + secondsDelta);
          updateDisplay();
          scheduleSave(state);
        }

        updateDisplay();

        if (timerState.running && timerState.lastStartedAt) {
          const lastStart = Date.parse(timerState.lastStartedAt);
          if (!Number.isNaN(lastStart)) {
            const elapsed = (Date.now() - lastStart) / 1000;
            timerState.remaining = Math.max(0, timerState.remaining - elapsed);
          }
          timerState.running = timerState.remaining > 0;
          if (timerState.running) {
            startInterval();
          } else {
            timerState.lastStartedAt = null;
            controller.lastTick = Date.now();
          }
          updateDisplay();
        }

        toggleBtn?.addEventListener('click', () => {
          if (timerState.running) {
            stopTimer();
          } else {
            startTimer();
          }
        });

        plusBtn?.addEventListener('click', () => adjust(10));
        minusBtn?.addEventListener('click', () => adjust(-10));
        timerControllers.set(teamId, controller);
      });
    }

    function renderPlayers(teamCard, teamData, state) {
      const playersContainer = teamCard.querySelector('[data-role="players"]');
      if (!playersContainer) {
        return;
      }
      playersContainer.innerHTML = '';
      const teamId = teamCard.dataset.teamId;
      const players = Array.isArray(teamData?.players) ? teamData.players : [];
      if (!state.players[teamId]) {
        state.players[teamId] = {};
      }
      const statePlayers = state.players[teamId];

      players.forEach((player, index) => {
        const playerId = typeof player?.id === 'string' && player.id.trim()
          ? player.id.trim()
          : `${teamId}-player-${index + 1}`;
        const wrapper = document.createElement('div');
        wrapper.className = 'game-ten__player';
        wrapper.dataset.playerId = playerId;

        const nameEl = document.createElement('span');
        nameEl.className = 'game-ten__player-name';
        nameEl.textContent = player?.name || `–ò–≥—Ä–æ–∫ ${index + 1}`;
        wrapper.appendChild(nameEl);

        const livesEl = document.createElement('div');
        livesEl.className = 'game-ten__player-lives';
        if (!statePlayers[playerId]) {
          statePlayers[playerId] = { lives: MAX_PLAYER_LIVES };
        }
        const playerState = statePlayers[playerId];

        for (let i = 0; i < MAX_PLAYER_LIVES; i += 1) {
          const lifeButton = document.createElement('button');
          lifeButton.type = 'button';
          lifeButton.className = 'game-ten__life';
          lifeButton.dataset.index = String(i);
          lifeButton.setAttribute('aria-pressed', i < playerState.lives ? 'true' : 'false');
          lifeButton.title = '–ö–ª–∏–∫–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –∂–∏–∑–Ω—å';
          livesEl.appendChild(lifeButton);
        }

        livesEl.addEventListener('click', (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement) || !target.classList.contains('game-ten__life')) {
            return;
          }
          const lifeIndex = Number.parseInt(target.dataset.index || '0', 10);
          const current = state.players[teamId][playerId]?.lives ?? MAX_PLAYER_LIVES;
          const nextLives = lifeIndex < current ? lifeIndex : lifeIndex + 1;
          state.players[teamId][playerId].lives = Math.min(Math.max(nextLives, 0), MAX_PLAYER_LIVES);
          Array.from(livesEl.querySelectorAll('.game-ten__life')).forEach((buttonEl, idx) => {
            buttonEl.setAttribute('aria-pressed', idx < state.players[teamId][playerId].lives ? 'true' : 'false');
          });
          scheduleSave(state);
          updateActivePlayerHighlight(state);
        });

        wrapper.appendChild(livesEl);
        playersContainer.appendChild(wrapper);
      });
    }

    function renderHints(teamCard, teamData, activeData, state) {
      const hintsContainer = teamCard.querySelector('[data-role="hints"]');
      if (!hintsContainer) {
        return;
      }
      hintsContainer.innerHTML = '';
      const teamId = teamCard.dataset.teamId;
      const hints = Array.isArray(activeData?.hints) ? activeData.hints : [];
      if (!state.hints[teamId]) {
        state.hints[teamId] = {};
      }
      const stateHints = state.hints[teamId];

      hints.forEach((hint, index) => {
        const hintId = typeof hint?.id === 'string' && hint.id.trim()
          ? hint.id.trim()
          : `hint-${index + 1}`;
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'game-ten__hint';
        button.dataset.hintId = hintId;
        button.setAttribute('aria-pressed', stateHints[hintId] ? 'true' : 'false');
        const icon = hint?.icon || HINT_ICONS[hintId] || 'üí°';
        const labelText = hint?.label || `–ü–æ–¥—Å–∫–∞–∑–∫–∞ ${index + 1}`;
        button.setAttribute('aria-label', labelText);
        button.innerHTML = `<span class="game-ten__hint-icon" aria-hidden="true">${icon}</span><span class="sr-only">${labelText}</span>`;
        const description = hint?.description;
        button.title = description || labelText;
        button.addEventListener('click', () => {
          state.hints[teamId][hintId] = !state.hints[teamId][hintId];
          button.setAttribute('aria-pressed', state.hints[teamId][hintId] ? 'true' : 'false');
          scheduleSave(state);
        });
        hintsContainer.appendChild(button);
      });
    }

    function updateActivePlayerHighlight(state) {
      const activeId = state.activePlayerId;
      gameRoot.querySelectorAll('.game-ten__player').forEach((playerEl) => {
        const playerId = playerEl.dataset.playerId;
        playerEl.classList.toggle('is-active', activeId === playerId);
      });
    }

    function renderTeams(activeData, state) {
      const teamsData = Array.isArray(activeData?.teams) ? activeData.teams : [];
      const teamsContainer = gameRoot.querySelector('.game-ten__hud-teams');
      const existingCards = Array.from(gameRoot.querySelectorAll('.game-ten__team-card'));

      while (existingCards.length < teamsData.length) {
        const clone = existingCards[existingCards.length - 1].cloneNode(true);
        clone.dataset.teamSlot = String(existingCards.length);
        teamsContainer.appendChild(clone);
        existingCards.push(clone);
      }
      while (existingCards.length > teamsData.length) {
        const card = existingCards.pop();
        card?.remove();
      }

      const cards = Array.from(gameRoot.querySelectorAll('.game-ten__team-card'));
      cards.forEach((teamCard, index) => {
        const teamData = teamsData[index];
        if (!teamData) {
          return;
        }
        const teamId = typeof teamData?.id === 'string' && teamData.id.trim()
          ? teamData.id.trim()
          : `team-${index + 1}`;
        teamCard.dataset.teamId = teamId;

        const teamNameEl = teamCard.querySelector('[data-role="team-name"]');
        if (teamNameEl) {
          teamNameEl.textContent = teamData?.name || `–ö–æ–º–∞–Ω–¥–∞ ${index + 1}`;
        }

        const teamLifeButton = teamCard.querySelector('[data-role="team-life"]');
        if (teamLifeButton) {
          if (typeof state.teamLives[teamId] !== 'boolean') {
            state.teamLives[teamId] = true;
          }
          teamLifeButton.setAttribute('aria-pressed', state.teamLives[teamId] ? 'true' : 'false');
          teamLifeButton.addEventListener('click', () => {
            state.teamLives[teamId] = !state.teamLives[teamId];
            teamLifeButton.setAttribute('aria-pressed', state.teamLives[teamId] ? 'true' : 'false');
            scheduleSave(state);
          });
        }

        renderPlayers(teamCard, teamData, state);
        renderHints(teamCard, teamData, activeData, state);
      });

      setupTimers(state, cards);
      return cards;
    }

    function renderQuestionHeader(questionMeta) {
      const numberEl = gameRoot.querySelector('[data-role="question-number"]');
      if (numberEl) {
        if (questionMeta && Number.isFinite(questionMeta.number)) {
          numberEl.textContent = `${questionMeta.number}.`;
        } else {
          numberEl.textContent = '‚Äì';
        }
      }

      const themeEl = gameRoot.querySelector('[data-role="theme"]');
      if (themeEl) {
        if (questionMeta) {
          themeEl.textContent = questionMeta.theme || '–¢–µ–º–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞';
        } else {
          themeEl.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É –≤–æ–ø—Ä–æ—Å–∞';
        }
      }

      const subtitleEl = gameRoot.querySelector('[data-role="subtitle"]');
      if (subtitleEl) {
        if (!questionMeta) {
          subtitleEl.hidden = false;
          subtitleEl.textContent = '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫—É, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –≤–æ–ø—Ä–æ—Å.';
        } else {
          const subtitleText = questionMeta.subtitle || questionMeta.title || '';
          if (subtitleText) {
            subtitleEl.hidden = false;
            subtitleEl.textContent = subtitleText;
          } else {
            subtitleEl.hidden = true;
            subtitleEl.textContent = '';
          }
        }
      }

      const promptTextEl = gameRoot.querySelector('[data-role="prompt-text"]');
      if (promptTextEl) {
        if (!questionMeta) {
          promptTextEl.hidden = false;
          promptTextEl.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ –≤–æ–ø—Ä–æ—Å, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–∞—É–Ω–¥.';
        } else {
          const promptText = questionMeta.prompt || questionMeta.title || '–¢–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞ –Ω–µ —É–∫–∞–∑–∞–Ω.';
          promptTextEl.hidden = false;
          promptTextEl.textContent = promptText;
        }
      }

      scheduleGridSizing();
    }

    function ensureQuestionState(state, questionMeta) {
      if (!questionMeta) {
        return null;
      }
      const answerCount = Array.isArray(questionMeta.answers) ? questionMeta.answers.length : 0;
      const allowedStatuses = ['neutral', 'correct', 'incorrect'];
      let entry = state.questionStates[questionMeta.id];
      if (!entry) {
        entry = {
          answers: [],
          selectedAnswer: null,
          used: false,
        };
        state.questionStates[questionMeta.id] = entry;
      }
      entry.answers = Array.from({ length: answerCount }, (_, index) => {
        const existing = entry.answers?.[index];
        if (!existing || typeof existing !== 'object') {
          return { status: 'neutral', revealed: false };
        }
        const status = allowedStatuses.includes(existing.status) ? existing.status : 'neutral';
        const revealed = Boolean(existing.revealed);
        return { status, revealed };
      });
      if (!Number.isInteger(entry.selectedAnswer) || entry.selectedAnswer < 0 || entry.selectedAnswer >= answerCount) {
        entry.selectedAnswer = null;
      }
      entry.used = Boolean(entry.used);
      return entry;
    }

    function updateQuestionSelectionCards(state) {
      const cards = gameRoot.querySelectorAll('.game-ten__selection-card');
      cards.forEach((card) => {
        const questionId = card.dataset.questionId;
        const questionState = questionId ? state.questionStates[questionId] : null;
        card.classList.toggle('is-active', state.selectedQuestionId === questionId);
        card.classList.toggle('is-used', Boolean(questionState?.used));
      });
    }

    function renderQuestionSelection(questions, state, onSelect) {
      const selection = gameRoot.querySelector('[data-role="question-selection"]');
      const grid = selection?.querySelector('[data-role="question-grid"]');
      if (!selection || !grid) {
        return;
      }
      grid.innerHTML = '';
      questions.forEach((question) => {
        const card = document.createElement('button');
        card.type = 'button';
        card.className = 'game-ten__selection-card';
        card.dataset.questionId = question.id;

        const numberEl = document.createElement('span');
        numberEl.className = 'game-ten__selection-number';
        numberEl.textContent = `–í–æ–ø—Ä–æ—Å ${question.number}`;
        card.appendChild(numberEl);

        const themeEl = document.createElement('span');
        themeEl.className = 'game-ten__selection-theme';
        themeEl.textContent = question.theme || '–ë–µ–∑ —Ç–µ–º—ã';
        card.appendChild(themeEl);

        const titleEl = document.createElement('span');
        titleEl.className = 'game-ten__selection-title-text';
        titleEl.hidden = true;
        titleEl.textContent = '';
        card.appendChild(titleEl);

        card.addEventListener('click', () => {
          onSelect(question);
        });

        grid.appendChild(card);
      });

      updateQuestionSelectionCards(state);
    }

    function showQuestionSelection(state, { skipSave = false } = {}) {
      const selection = gameRoot.querySelector('[data-role="question-selection"]');
      const questionView = gameRoot.querySelector('[data-role="question-view"]');
      if (selection) {
        selection.hidden = false;
      }
      if (questionView) {
        questionView.hidden = true;
      }
      const revealBody = gameRoot.querySelector('[data-role="reveal-body"]');
      if (revealBody) {
        revealBody.textContent = '';
        revealBody.hidden = true;
      }
      const previousSelected = state.selectedQuestionId;
      state.selectedQuestionId = null;
      renderQuestionHeader(null);
      updateQuestionSelectionCards(state);
      scheduleGridSizing();
      if (!skipSave && previousSelected !== null) {
        scheduleSave(state);
      }
    }

    function renderAnswersForQuestion(questionMeta, questionState, state) {
      const answers = Array.isArray(questionMeta.answers) ? questionMeta.answers : [];
      const tiles = Array.from(gameRoot.querySelectorAll('.game-ten__tile'));
      const revealBody = gameRoot.querySelector('[data-role="reveal-body"]');

      function applyAnswerState(index) {
        const tile = tiles[index];
        if (!tile) {
          return;
        }
        tile.classList.remove('is-correct', 'is-incorrect', 'is-selected');
        const entry = questionState.answers[index];
        if (!entry) {
          return;
        }
        if (entry.status === 'correct') {
          tile.classList.add('is-correct');
        } else if (entry.status === 'incorrect') {
          tile.classList.add('is-incorrect');
        }
        if (questionState.selectedAnswer === index) {
          tile.classList.add('is-selected');
        }
      }

      function updateRevealBody() {
        if (!revealBody) {
          return;
        }
        const selectedIndex = Number.isInteger(questionState.selectedAnswer)
          ? questionState.selectedAnswer
          : null;
        if (selectedIndex === null || !questionState.answers[selectedIndex]?.revealed) {
          revealBody.textContent = '';
          revealBody.hidden = true;
          return;
        }
        const answer = answers[selectedIndex];
        if (!answer) {
          revealBody.textContent = '';
          revealBody.hidden = true;
          return;
        }
        const comment = typeof answer.comment === 'string' && answer.comment.trim()
          ? answer.comment.trim()
          : (typeof answer.reveal === 'string' && answer.reveal.trim() ? answer.reveal.trim() : '');
        if (comment) {
          revealBody.textContent = comment;
          revealBody.hidden = false;
          if (typeof revealBody.scrollIntoView === 'function') {
            window.requestAnimationFrame(() => {
              try {
                revealBody.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
              } catch (error) {
                revealBody.scrollIntoView();
              }
            });
          }
        } else {
          revealBody.textContent = '';
          revealBody.hidden = true;
        }
        scheduleGridSizing();
      }

      tiles.forEach((tile, index) => {
        const answerData = answers[index];
        tile.classList.remove('is-hidden', 'is-correct', 'is-incorrect', 'is-selected');
        tile.dataset.questionId = questionMeta.id;
        tile.dataset.answerIndex = String(index);

        if (!answerData) {
          tile.classList.add('is-hidden');
          tile.dataset.answerId = '';
          tile.dataset.correct = '';
          const tileImage = tile.querySelector('[data-role="tile-image"]');
          tileImage?.classList.add('is-empty');
          const tileImg = tile.querySelector('[data-role="tile-img"]');
          if (tileImg) {
            tileImg.removeAttribute('src');
            tileImg.alt = '';
            tileImg.hidden = true;
          }
          const tileCaption = tile.querySelector('[data-role="tile-caption"]');
          if (tileCaption) {
            tileCaption.textContent = `–û—Ç–≤–µ—Ç ${index + 1}`;
          }
          tile.onclick = null;
          tile.onkeydown = null;
          return;
        }

        const tileImage = tile.querySelector('[data-role="tile-image"]');
        const tileImg = tile.querySelector('[data-role="tile-img"]');
        const tileCaption = tile.querySelector('[data-role="tile-caption"]');
        const captionText = answerData.caption && String(answerData.caption).trim()
          ? String(answerData.caption).trim()
          : `–û—Ç–≤–µ—Ç ${index + 1}`;
        const imageUrl = typeof answerData.image === 'string' ? answerData.image.trim() : '';

        if (tileImage && tileImg) {
          if (imageUrl) {
            tileImg.src = imageUrl;
            tileImg.alt = captionText;
            tileImg.hidden = false;
            tileImage.classList.remove('is-empty');
          } else {
            tileImg.removeAttribute('src');
            tileImg.alt = '';
            tileImg.hidden = true;
            tileImage.classList.add('is-empty');
          }
        }

        if (tileCaption) {
          tileCaption.textContent = captionText;
        }

        const answerId = typeof answerData.id === 'string' && answerData.id.trim()
          ? answerData.id.trim()
          : `answer-${index + 1}`;
        tile.dataset.answerId = answerId;
        tile.dataset.correct = answerData.is_correct ? 'true' : 'false';

        const handleActivation = () => {
          const entry = questionState.answers[index];
          if (!entry) {
            return;
          }
          const isCorrect = Boolean(answerData.is_correct);
          const targetStatus = isCorrect ? 'correct' : 'incorrect';
          if (entry.status === targetStatus && entry.revealed) {
            entry.status = 'neutral';
            entry.revealed = false;
            if (questionState.selectedAnswer === index) {
              questionState.selectedAnswer = null;
            }
          } else {
            entry.status = targetStatus;
            entry.revealed = true;
            questionState.selectedAnswer = index;
          }
          tiles.forEach((_, idx) => applyAnswerState(idx));
          updateRevealBody();
          scheduleSave(state);
        };

        tile.onclick = handleActivation;
        tile.onkeydown = (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            handleActivation();
          }
        };
      });

      if (!Number.isInteger(questionState.selectedAnswer) || questionState.selectedAnswer >= answers.length) {
        questionState.selectedAnswer = null;
      }

      tiles.forEach((_, idx) => applyAnswerState(idx));
      updateRevealBody();
      scheduleGridSizing();
    }

    function showQuestion(questionMeta, state, { skipSave = false } = {}) {
      if (!questionMeta) {
        showQuestionSelection(state, { skipSave });
        return;
      }

      const selection = gameRoot.querySelector('[data-role="question-selection"]');
      const questionView = gameRoot.querySelector('[data-role="question-view"]');
      if (selection) {
        selection.hidden = true;
      }
      if (questionView) {
        questionView.hidden = false;
      }

      const questionState = ensureQuestionState(state, questionMeta);
      if (!questionState) {
        renderQuestionHeader(questionMeta);
        return;
      }

      const previousSelected = state.selectedQuestionId;
      const wasUsed = questionState.used;
      state.selectedQuestionId = questionMeta.id;
      if (!questionState.used) {
        questionState.used = true;
      }

      renderQuestionHeader(questionMeta);
      renderAnswersForQuestion(questionMeta, questionState, state);
      updateQuestionSelectionCards(state);
      scheduleGridSizing();

      if (!skipSave && (previousSelected !== questionMeta.id || !wasUsed)) {
        scheduleSave(state);
      }
    }

    function renderActivePlayerSelect(activeData, state) {
      const select = gameRoot.querySelector('[data-role="active-player"]');
      if (!select) {
        return;
      }
      select.innerHTML = '';
      select.style.width = '';
      const teams = Array.isArray(activeData?.teams) ? activeData.teams : [];
      const options = [];
      teams.forEach((team, teamIndex) => {
        const teamId = typeof team?.id === 'string' && team.id.trim()
          ? team.id.trim()
          : `team-${teamIndex + 1}`;
        const players = Array.isArray(team?.players) ? team.players : [];
        players.forEach((player, playerIndex) => {
          const playerId = typeof player?.id === 'string' && player.id.trim()
            ? player.id.trim()
            : `${teamId}-player-${playerIndex + 1}`;
          const option = document.createElement('option');
          option.value = playerId;
          option.textContent = `${team?.name || `–ö–æ–º–∞–Ω–¥–∞ ${teamIndex + 1}`}: ${player?.name || `–ò–≥—Ä–æ–∫ ${playerIndex + 1}`}`;
          select.appendChild(option);
          options.push(playerId);
        });
      });
      const fallback = options.includes(state.activePlayerId) ? state.activePlayerId : options[0] || '';
      state.activePlayerId = fallback || null;
      select.value = fallback || '';
      autosizeSelect(select);
      select.onchange = () => {
        state.activePlayerId = select.value || null;
        updateActivePlayerHighlight(state);
        scheduleSave(state);
        autosizeSelect(select);
      };
      updateActivePlayerHighlight(state);
    }

    function renderAnswers(activeData, state) {
      console.warn('renderAnswers is deprecated. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ showQuestion().');
      if (!activeData) {
        showQuestionSelection(state);
        return;
      }
      const questions = normalizeQuestions(activeData);
      const target = questions.find((question) => question.id === state.selectedQuestionId) || questions[0];
      if (target) {
        showQuestion(target, state, { skipSave: true });
      } else {
        showQuestionSelection(state, { skipSave: true });
      }
    }

    (async () => {
      try {
        const activeData = await loadJson(activeUrl);
        const questions = normalizeQuestions(activeData);

        let runData = null;
        if (runUrl) {
          try {
            runData = await loadJson(runUrl, { allowNotFound: true });
          } catch (error) {
            console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å game_run.json, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.', error);
          }
        }

        const defaultState = createDefaultState(activeData, questions);
        const state = mergeState(defaultState, runData, activeData, questions);

        questions.forEach((question) => {
          ensureQuestionState(state, question);
        });

        renderQuestionSelection(questions, state, (question) => {
          showQuestion(question, state);
        });
        const teamCards = renderTeams(activeData, state);
        renderActivePlayerSelect(activeData, state);
        updateActivePlayerHighlight(state);
        hideError();

        const homeLink = gameRoot.querySelector('[data-role="home-link"]');
        homeLink?.addEventListener('click', (event) => {
          event.preventDefault();
          showQuestionSelection(state);
        });

        const initialQuestion = questions.find((question) => question.id === state.selectedQuestionId);
        if (initialQuestion) {
          showQuestion(initialQuestion, state, { skipSave: true });
        } else {
          showQuestionSelection(state, { skipSave: true });
        }

        if (!runData && runUrl) {
          scheduleSave(state);
        }
      } catch (error) {
        console.error(error);
        showError(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∏–≥—Ä—ã.');
      }
    })();
  });
</script>
{% endblock %}
